---
title: "VCA and Respo Plots"
author: "Hannah Merges"
date: "`r Sys.Date()`"
output: 
  rmdformats::readthedown
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load libraries
```{r, echo=FALSE}
library(here)
library(tidyverse) 
library(lme4)
library(lmerTest)
library(VCA)
library(performance)
library(sjPlot)
```

### Read in your data 
```{r, echo=FALSE}
RespoR_Normalized_Full_withNEC_nutrients <- read_csv(here::here("Data", "RespoR_Normalized_Full_withNEC_andallnutrients.csv"))
```

### Tidy dataset and organize to separate R, GP, and C 
-  I just did this to make sure there are no typos in the colonyID etc and also to be explicit about the column names
-  eventually reorder and join together 
```{r}
R1<-RespoR_Normalized_Full_withNEC_nutrients %>%
  filter(P_R=="R") %>%
  filter(!is.infinite(umol.cm2.hr)) %>%
  filter(sample_ID!="Varari_Col4_Dil9_Light") %>%
  rename(Resp = umol.cm2.hr)%>%
  select(new_colonynumber, SGD_number, site, date, log_silicate, log_silicate2,silicate_umolL, Resp)

GP1<-RespoR_Normalized_Full_withNEC_nutrients %>%
  filter(P_R=="GP") %>%
  filter(!is.infinite(umol.cm2.hr)) %>%
  filter(sample_ID!="Varari_Col4_Dil9_Light")%>%
  rename(GP = umol.cm2.hr)%>%
  select(new_colonynumber, SGD_number, site, date, log_silicate, log_silicate2,silicate_umolL, GP)

C1<-RespoR_Normalized_Full_withNEC_nutrients %>%
  filter(P_R=="C") %>%
  filter(!is.infinite(umol.cm2.hr)) %>%
  filter(sample_ID!="Varari_Col4_Dil9_Light")%>%
  rename(C = umol.cm2.hr)%>%
  select(new_colonynumber, SGD_number, site, date, log_silicate, log_silicate2,silicate_umolL, C)


# bring it together into a wide dataset
Wide<-left_join(R1,GP1)

Wide<-Wide %>% left_join(C1)%>%
  mutate(SGD_number = as.factor(SGD_number)) %>%
  drop_na()
```

### Create models
-  model breakdown: 
-  Fixed Effects = **log_silicate**: represents the linear relationship between the natural log of silicate and the response variable (Resp or umol) and **I(log_silicate^2)**: a quadratic effect of the log_silicate variable. By adding the square of log_silicate, you are testing whether there is a non-linear relationship between log_silicate and the response (Resp).
-  Random Effects **new_colonynumber**: This is a random intercept for each new_colonynumber. Allows each colony to have its own baseline (intercept) while assuming that the slope of log_silicate and its quadratic term are the same across colonies. *The 1 signifies that only the intercept varies across levels of new_colonynumber* **date**: This term accounts for random variation by date. Each date can have its own random intercept to account for variation that occurs across different dates. **site**: This allows the model to account for site-specific differences by letting each site have its own random intercept.

-  Also controlling for convergence behavior in the model fitting process
-  **lmerControl** allows the model to ignore warnings about singular fits, which often arise when the random effects structure is too complex relative to the data (e.g., when there is insufficient variability among random effects). Basically don't want the model to be overly sensitive 

```{r}
# Respiration models
modeltest_R <- lmer(Resp ~ log_silicate + I(log_silicate^2) + (1|new_colonynumber) + (1|date) + (1|site), data=Wide,
                    control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-1000)))
anova(modeltest_R)                      
summary(modeltest_R)                      
#check_model(modeltest_R)
r2_nakagawa(modeltest_R,iterations = 1000)

# GP models
modeltest_GP <- lmer(GP ~ log_silicate + I(log_silicate^2)+ (1|date) + (1|site)+(1|new_colonynumber), data=Wide,
                     control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-1000)))
anova(modeltest_GP)                      
summary(modeltest_GP) 
#check_model(modeltest_GP)
r2_nakagawa(modeltest_GP,iterations = 1000)

# C models
modeltest_C <- lmer(C ~ log_silicate  + (1|new_colonynumber) + (1|date) + (1|site), data=Wide,
                    control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-1000)))
anova(modeltest_C)                      
summary(modeltest_C) 
#check_model(modeltest_C)
r2_nakagawa(modeltest_C,iterations = 1000)
```


### Create VCAs

```{r}
# get the variance components manually for respiration 
R_var<-as_tibble(summary(modeltest_R)$varcor) # extract the variance 
R_var<-R_var %>% 
  mutate(percentvar_R = 100*sdcor/sum(sdcor)) %>% # calculate variance explained by each random effect
  select(grp, percentvar_R) # only select what I need


# get the variance components manually for gross photosynthesis  
GP_var<-as_tibble(summary(modeltest_GP)$varcor) # extract the variance 
GP_var<-GP_var %>% 
  mutate(percentvar_GP = 100*sdcor/sum(sdcor))%>% # calculate variance explained by each random effect
  select(grp, percentvar_GP) # only select what I need

# get the variance components manually for calcification 
C_var<-as_tibble(summary(modeltest_C)$varcor) # extract the variance 
C_var<-C_var %>% 
  mutate(percentvar_Cr = 100*sdcor/sum(sdcor)) %>% # calculate variance explained by each random effect
  select(grp, percentvar_Cr) # only select what I need

# bring them all together
# plot the VCA results 
variance_plot <- R_var %>%
  left_join(GP_var)%>%
  left_join(C_var) %>% 
  pivot_longer(cols = percentvar_R:percentvar_Cr) %>% # pivot to get ready for a barplot
  mutate(nicenames = case_when(name == "percentvar_R" ~ "Respiration",
                               name == "percentvar_GP" ~ "Gross Photosynthesis",
                               name == "percentvar_Cr" ~ "Calcification"
                               
  ))%>%
  mutate(grp = case_when(grp == "new_colonynumber"~ "Genotype",
                          grp == "date"~ "Date",
                          grp == "site"~ "Site",
                         grp == "Residual"~"Residual"))%>%
  mutate(grp = factor(grp, levels = c("Residual","Genotype","Date","Site"))) %>% # put the levels in an order I want for plotting
  ggplot(aes(x = nicenames, 
             y = value, 
             fill = grp))+
  geom_bar(stat = "identity")+
  labs(x = "",
       y = "Percent Variance explained (%)",
       fill = "Group")+
  theme_minimal() + 
  scale_fill_manual(values=c("gray", "coral3", "deepskyblue2", "burlywood"))

variance_plot
```


## New plots based on updated models 

#### standardized effect plots 
-  **what is a standardized effect plot?**
-  visually compare which predictors have the strongest and weakest effects on the response variable, regardless of the units or scales of the predictors
-  In regression, predictors may have different units. To compare their relative impact, we standardize both the predictors and response. This is done by converting them to z-scores, meaning that they have a mean of 0 and a standard deviation of 1. The resulting coefficients (effect sizes) are then expressed in terms of standard deviations, allowing for direct comparison.

-  None of the effects cross 0 so they are all significant, but not from each other because the error bars overlap? But log_silicate trends towards being most significant for GP rates 
```{r}

###############################
# standardized effect size plots
###############################
plot_model(modeltest_GP, type = "std") # give standardized effect sizes
plot_model(modeltest_R, type = "std")
plot_model(modeltest_C, type = "std")


### lets put it all on the same plot though for comparison... extract the data from plot_model
GP_std<-tibble(plot_model(modeltest_GP, type = "std")$data) %>%
  mutate(Rate = "Gross Photosynthesis")

R_std<-tibble(plot_model(modeltest_R, type = "std")$data) %>%
  mutate(Rate = "Respiration")

C_std<-tibble(plot_model(modeltest_C, type = "std")$data) %>%
  mutate(Rate = "Calcification")

## bind it all
all_std<-GP_std %>%
  bind_rows(R_std)%>%
  bind_rows(C_std)

# plot a standardized effects plot all together
standardized_effects <- all_std %>%
  ggplot(aes(x = estimate, 
             y = term, 
             color = Rate))+
  geom_vline(xintercept = 0, linetype = 2) +
  geom_point(size = 3, 
             position = position_dodge(0.9)) + # dodge the points so not on top of each other
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high), width = 0, position = position_dodge(0.9)) +
  labs(x = "Standardized effect",
       y = "Term")+
  theme_bw()

standardized_effects 

```

#### Respiration plot

```{r}
###############################
## create tibble for R data  
###############################

R_newdata<-tibble(umol.cm2.hr = rep(seq(0,0.5,0.01),14), # min to max ranges from ~ 0 - 0.5. There are 14 colonies so repeate this sequence 14 times
                  log_silicate =rep(seq(0.5,3.5,0.06),14), # the min log Si is ~1 and the max is ~ 3.3- make a a sequience that is within that range that is the same length as the sequence for R
                  silicate = exp(log_silicate), # take the exponent of the log Si to get raw si
                  new_colonynumber = c(rep(1,51),rep(2,51),rep(3,51),rep(4,51), # repeate each colony number the same size as the new silicate and umol data
                                       rep(5,51),rep(6,51),rep(7,51),rep(8,51),
                                       rep(13,51),rep(14,51),rep(15,51),rep(16,51),
                                       rep(17,51),rep(18,51)),
                  date = c(rep("6/17/23",51),rep("6/17/23",51),rep("6/17/23",51),rep("6/18/23",51), # make a date vector that alignes with each colony vector that is als the same length
                           rep("6/21/23",51),rep("6/21/23",51),rep("6/22/23",51),rep("6/22/23",51),
                           rep("6/10/23",51),rep("6/10/23",51),rep("6/11/23",51),rep("6/11/23",51),
                           rep("6/12/23",51),rep("6/12/23",51)),
                  site  = ifelse(new_colonynumber %in% 1:8, "Varari","Cabral")) # but in the site names

# create a color gradient for Varari
colfunc_V <- colorRampPalette(c("firebrick1", "firebrick4"))
Vcolors<-colfunc_V(8) # create 8 colors between the lightest and darkest firebrick

# create a color gradient for cabral
colfunc_c <- colorRampPalette(c("goldenrod1", "goldenrod4"))
Ccolors<-colfunc_c(6) # create 8 colors between the lightest and darkest goldenrod. There are only 6 Cabral corals


color_values<-c(Vcolors,Ccolors) # make a color value for everything together

##########################################
# create a new data frame that is the size of the prediction data frame
##########################################
plot_df_R <- tibble(silicate = R_newdata$silicate,
                    log_silicate = R_newdata$log_silicate,
                    pred_umol = predict(modeltest_R, newdata = R_newdata),
                    new_colonynumber = as.factor(R_newdata$new_colonynumber))

##########################################
# edits based on errors in simple predict function 
##########################################

# Define a function for prediction
pred_fun <- function(fit) {
  predict(fit, newdata = Wide, re.form = ~0)
}

# Bootstrapping to get standard errors (adjust 'nsim' for more precision)
boot_res <- bootMer(modeltest_R, pred_fun, nsim = 100) # Set nsim as needed

# Predictions from the original model
predictions <- predict(modeltest_R, newdata = Wide, re.form = ~0)

# Standard errors from bootstrapping
se_fit <- apply(boot_res$t, 2, sd)

# Combine predictions and SEs into a tibble
predict_r <- tibble(fit = predictions, se = se_fit, silicate = Wide$silicate_umolL)

# Output the tibble
predict_r


##########################################
# make the plot
##########################################

Rplot<-ggplot() + # first plot the original data in the background and make it a bit transparent
  geom_point(data = R1, 
             alpha = 0.5, 
             aes(x= silicate_umolL,
                 y= Resp,
                 color = factor(new_colonynumber),
                 fill = site), # I added fill = site so that I can remove the colony number legend and just have one for site for ease of interpretation
             shape = 21 # this shape makes the color the border and fill the middle
  ) + # bring in the raw data first.  Because I wanted to show this on the raw scale I used raw silicate and then transformed it
  
  geom_line(data = predict_r, aes(x = silicate, y = fit), color = "black", linewidth = 1.5) + # prediction for just fixed effect
 # geom_ribbon(data = predict_r, aes(x = silicate, ymin = fit-se, ymax = fit+se), alpha = 0.2, color = "grey")+
  
   geom_line(data = plot_df_R, aes(x = silicate, # Make prediction lines this needs to be spelled the same as the plot datframe with new data.. not your original one. 
                                  y = pred_umol,
                                  color = new_colonynumber
  ), linetype = 1, size = 0.7, show.legend = "FALSE") +

  coord_trans(x ="log") + # transform the axes
  scale_color_manual(values = color_values) + # add in the color values
  scale_fill_manual(values = c("goldenrod","firebrick"))+ # add in fill values for site
  scale_x_continuous(breaks = c(2,10,20,30))+
  guides(color = "none") + # delete the guide for color
  labs(linetype = NULL, 
       color = " ",
       fill = " ",
       x = expression(Silicate~(mu*mol~L^-1)),
       y = expression(Respiration~(mu*mol~cm^-1~hr^-1)) )+
  theme_bw()+
  theme(legend.position = "top",
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        plot.title = element_text(face = 2, hjust = 0.5),
        panel.border = element_rect(fill = NA, linewidth = 0.2))


Rplot

# if you want to see what your random effects are
lme4::ranef(modeltest_R,condVar = TRUE)
```


#### Gross Photosynthesis plot 

```{r}

###############################
## create tibble for GP data  
###############################

GP_newdata <- tibble(umol.cm2.hr = rep(seq(0,1.5,0.01), each = 1, length.out = 714), # min to max ranges from ~ 0.18 - 1.4. The first number is the min, the second number is the max value you want, and the third number is the interval you want to build the sequence with. There are 14 colonies so repeat this sequence 14 times (fourth number)
                  log_silicate =rep(seq(0.5,3.5,0.06),14), # the min log Si is ~1.02 and the max is ~ 3.2- make a a sequence that is within that range that is the same length as the sequence for R
                  silicate = exp(log_silicate), # take the exponent of the log Si to get raw si
                  new_colonynumber = c(rep(1,51),rep(2,51),rep(3,51),rep(4,51), # repeat each colony number the same size as the new silicate and umol data
                                       rep(5,51),rep(6,51),rep(7,51),rep(8,51),
                                       rep(13,51),rep(14,51),rep(15,51),rep(16,51),
                                       rep(17,51),rep(18,51)),
                  date = c(rep("6/17/23",51),rep("6/17/23",51),rep("6/17/23",51),rep("6/18/23",51), # make a date vector that alignes with each colony vector that is all the same length
                             rep("6/21/23",51),rep("6/21/23",51),rep("6/22/23",51),rep("6/22/23",51),
                             rep("6/10/23",51),rep("6/10/23",51),rep("6/11/23",51),rep("6/11/23",51),
                             rep("6/12/23",51),rep("6/12/23",51)),
                  site  = ifelse(new_colonynumber %in% 1:8, "Varari","Cabral")) # but in the site names

# create a color gradient for Varari
colfunc_V <- colorRampPalette(c("firebrick1", "firebrick4"))
Vcolors<-colfunc_V(8) # create 8 colors between the lightest and darkest firebrick

# create a color gradient for cabral
colfunc_c <- colorRampPalette(c("goldenrod1", "goldenrod4"))
Ccolors<-colfunc_c(6) # create 8 colors between the lightest and darkest goldenrod. There are only 6 Cabral corals


color_values<-c(Vcolors,Ccolors) # make a color value for everything together

##########################################
# create a new data frame that is the size of the prediction data frame
##########################################
plot_df_GP <- tibble(silicate = GP_newdata$silicate,
                    log_silicate = GP_newdata$log_silicate,
                    pred_umol = predict(modeltest_GP, newdata = GP_newdata),
                    new_colonynumber = as.factor(GP_newdata$new_colonynumber))

##########################################
# edits based on errors in simple predict function 
##########################################

# Define a function for prediction
pred_funGP <- function(fit) {
  predict(fit, newdata = Wide, re.form = ~0)
}

# Bootstrapping to get standard errors (adjust 'nsim' for more precision)
boot_resGP <- bootMer(modeltest_GP, pred_funGP, nsim = 100) # Set nsim as needed

# Predictions from the original model
predictionsGP <- predict(modeltest_GP, newdata = Wide, re.form = ~0)

# Standard errors from bootstrapping
se_fitGP <- apply(boot_resGP$t, 2, sd)

# Combine predictions and SEs into a tibble
predict_GP <- tibble(fitGP = predictionsGP, se = se_fitGP, silicate = Wide$silicate_umolL)

# Output the tibble
predict_GP


##########################################
# make the plot
##########################################

GPplot<-ggplot() + # first plot the original data in the background and make it a bit transparent
  geom_point(data = GP1, 
             alpha = 0.5, 
             aes(x= silicate_umolL,
                 y= GP,
                 color = factor(new_colonynumber),
                 fill = site), # I added fill = site so that I can remove the colony number legend and just have one for site for ease of interpretation
             shape = 21 # this shape makes the color the border and fill the middle
  ) + # bring in the raw data first.  Because I wanted to show this on the raw scale I used raw silicate and then transformed it
  
  geom_line(data = predict_GP, aes(x = silicate, y = fitGP), color = "black", linewidth = 1.5) + # prediction for just fixed effect
 # geom_ribbon(data = predict_r, aes(x = silicate, ymin = fit-se, ymax = fit+se), alpha = 0.2, color = "grey")+
  
   geom_line(data = plot_df_GP, aes(x = silicate, # Make prediction lines this needs to be spelled the same as the plot datframe with new data.. not your original one. 
                                  y = pred_umol,
                                  color = new_colonynumber), 
             linetype = 1, size = 0.7, show.legend = "FALSE") +

  coord_trans(x ="log") + # transform the axes
  scale_color_manual(values = color_values) + # add in the color values
  scale_fill_manual(values = c("goldenrod","firebrick"))+ # add in fill values for site
  scale_x_continuous(breaks = c(2,10,20,30))+
  guides(color = "none") + # delete the guide for color
  labs(linetype = NULL, 
       color = " ",
       fill = " ",
       x = expression(Silicate~(mu*mol~L^-1)),
       y = expression(Gross~Photosynthesis~(mu*mol~cm^-1~hr^-1)) )+
  theme_bw()+
  theme(legend.position = "top",
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        plot.title = element_text(face = 2, hjust = 0.5),
        panel.border = element_rect(fill = NA, linewidth = 0.2))


GPplot

# if you want to see what your random effects are
lme4::ranef(modeltest_GP,condVar = TRUE)
```


#### Calcification plot 

```{r}
###############################
## create tibble for C data  
###############################

C_newdata <- tibble(umol.cm2.hr = rep(seq(0,1.5,0.01), each = 1, length.out = 714),
  log_silicate = rep(seq(0.5,3.5,0.06), 14),
  silicate = exp(log_silicate),
  new_colonynumber = c(rep(1,51),rep(2,51),rep(3,51),rep(4,51),
                              rep(5,51),rep(6,51),rep(7,51),rep(8,51),
                              rep(13,51),rep(14,51),rep(15,51),rep(16,51),
                              rep(17,51),rep(18,51)),
  date = c(rep("6/17/23",51),rep("6/17/23",51),rep("6/17/23",51),rep("6/18/23",51),
           rep("6/21/23",51),rep("6/21/23",51),rep("6/22/23",51),rep("6/22/23",51),
           rep("6/10/23",51),rep("6/10/23",51),rep("6/11/23",51),rep("6/11/23",51),
           rep("6/12/23",51),rep("6/12/23",51)),
  site = ifelse(new_colonynumber %in% 1:8, "Varari", "Cabral"))

# create a color gradient for Varari
colfunc_V <- colorRampPalette(c("firebrick1", "firebrick4"))
Vcolors<-colfunc_V(8) # create 8 colors between the lightest and darkest firebrick

# create a color gradient for cabral
colfunc_c <- colorRampPalette(c("goldenrod1", "goldenrod4"))
Ccolors<-colfunc_c(6) # create 8 colors between the lightest and darkest goldenrod. There are only 6 Cabral corals


color_values<-c(Vcolors,Ccolors) # make a color value for everything together

##########################################
# create a new data frame that is the size of the prediction data frame
##########################################
plot_df_C <- tibble(silicate = C_newdata$silicate,
                    log_silicate = C_newdata$log_silicate,
                    pred_umol = predict(modeltest_C, newdata = C_newdata),
                    new_colonynumber = as.factor(C_newdata$new_colonynumber))

##########################################
# edits based on errors in simple predict function 
##########################################

# Define a function for prediction
pred_funC <- function(fit) {
  predict(fit, newdata = Wide, re.form = ~0)
}

# Bootstrapping to get standard errors (adjust 'nsim' for more precision)
boot_resC <- bootMer(modeltest_C, pred_funC, nsim = 100) # Set nsim as needed

# Predictions from the original model
predictionsC <- predict(modeltest_C, newdata = Wide, re.form = ~0)

# Standard errors from bootstrapping
se_fitC <- apply(boot_resC$t, 2, sd)

# Combine predictions and SEs into a tibble
predict_C <- tibble(fitC = predictionsC, se = se_fitC, silicate = Wide$silicate_umolL)

# Output the tibble
predict_C


##########################################
# make the plot
##########################################

Cplot<-ggplot() + # first plot the original data in the background and make it a bit transparent
  geom_point(data = C1, 
             alpha = 0.5, 
             aes(x= silicate_umolL,
                 y= C,
                 color = factor(new_colonynumber),
                 fill = site), # I added fill = site so that I can remove the colony number legend and just have one for site for ease of interpretation
             shape = 21 # this shape makes the color the border and fill the middle
  ) + # bring in the raw data first.  Because I wanted to show this on the raw scale I used raw silicate and then transformed it
  
  geom_line(data = predict_C, aes(x = silicate, y = fitC), color = "black", linewidth = 1.5) + # prediction for just fixed effect
 # geom_ribbon(data = predict_r, aes(x = silicate, ymin = fit-se, ymax = fit+se), alpha = 0.2, color = "grey")+
  
   geom_line(data = plot_df_C, aes(x = silicate, # Make prediction lines this needs to be spelled the same as the plot datframe with new data.. not your original one. 
                                  y = pred_umol,
                                  color = new_colonynumber), 
             linetype = 1, size = 0.7, show.legend = "FALSE") +

  coord_trans(x ="log") + # transform the axes
  scale_color_manual(values = color_values) + # add in the color values
  scale_fill_manual(values = c("goldenrod","firebrick"))+ # add in fill values for site
  scale_x_continuous(breaks = c(2,10,20,30))+
  guides(color = "none") + # delete the guide for color
  labs(linetype = NULL, 
       color = " ",
       fill = " ",
       x = expression(Silicate~(mu*mol~L^-1)),
       y = expression(Calcification~(mu*mol~cm^-1~hr^-1)) )+
  theme_bw()+
  theme(legend.position = "top",
        legend.text = element_text(size = 16),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        plot.title = element_text(face = 2, hjust = 0.5),
        panel.border = element_rect(fill = NA, linewidth = 0.2))


Cplot


# if you want to see what your random effects are
lme4::ranef(modeltest_C,condVar = TRUE)

```

## bring three plots together 
```{r}
#combined_plots <- Rplot+GPplot+Cplot

#combined_plots
```







